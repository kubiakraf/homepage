<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>brudnopis z WTFa</title>
    <linl href="./normalize.css" rel="stylesheet" type="text/css" />
    <link href="./style.css" rel="stylesheet" type="text/css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Tektur:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <main>
      <header class="header__img">
        <h1>JS</h1>
      </header>

      <nav class="navigation">
        <a href="./index.html">Home</a>
        <a href="./html.html">HTML</a>
        <a href="./css.html">CSS</a>
        <a href="./javascript.html">JS</a>
        <a href="./vcs.html">VSC</a>
        <a href="./git.html">git</a>
        <a href="./entities.html">entities</a>
        <a href="./power.html">Power User</a>
        <a href="./chat.html">ChatGPT</a>
        <a href="./net.html">Internet</a>
        <a href="./terminal.html">Terminal</a>
        <a href="./figma.html">Figma</a>
        <a href="./about.html">Wizytówka</a>
      </nav>

      <article>
        <h2>JS - JavaScript (język skryptowy)</h2>
        <ul>
          <li>Odpowiada za interakcje.</li>
          <li>Pozwala na programowanie we frontendzie (język obiektowy).</li>
          <li>Wpływa na każdą warstwę strony.</li>
          <li>Rozszerza możliwości zwykłych stron.</li>
          <li>Uruchamia się raz po załadowaniu strony.</li>
        </ul>
      </article>

      <article>
        <h2>ECMAScript 2015+ (ES6+)</h2>
        <ul>
          <li>ustandaryzowany przez organizację ECMA skryptowy język programowania</li>
          <li>JavaScript implementuje rzeczy ze specyfikacji ECMAScript</li>
          <li>Rozwój ECMAScript mocno przyśpieszył przez szerokie wykorzystanie JavaScriptu</li>
          <li>ES6 (i nowsze) wprowadzają wiele udogodnień dla developerów, co roku nowa wersja</li>
          <li>
            Nowe feature'y mogą nie być wspierane we wszystkich przeglądarkach (ale są na to
            sposoby)
          </li>
        </ul>
      </article>
    </main>

    <article>
      <h2>Z czego składa się JavaScript</h2>
      <ul>
        <li>
          Wartości - są tym dla JS czym liczby dla matematyki
          <ul>
            <li>
              Typy proste w JS (primitives) - rodzaje wartości
              <ul>
                <li>String - tekst, otaczamy ' lub " (zalecane ')</li>
                <li>Number - liczba</li>
                <li>Bigint - duża liczba, większa niż 2<sup>53</sup></li>
                <li>
                  boolean - true lub false, wykorzystywany do tworzenia logiki w JS, sprawdzania
                  warunków
                </li>
                <li>
                  null - wartość celowo niezdefiniowana, wiemy, że powinna jakaś być ale jej nie ma,
                  (typeof zwraca 'object' - wskazanie na pusty obiekt, wszystko w JS jest obiektem)
                </li>
                <li>
                  undefined - brak definicji - zmienna nigdzie nie deklarowana JS niewie co to jest
                </li>
                <li>
                  *symbol - tworzy "unikalne opakowanie" - praktycznie się z niego nie korzysta -
                  ciekawostka
                </li>
              </ul>
            </li>
            <li>typeof name - sprawdza w konsili typ zmiennej</li>
            <li>
              immutability - niemutowalność. Jeden z fundamentalnych konceptów JS. Nie możemy
              zmieniać wartości primitive values w JS. To co zmieniamy to połączenia między nimi, a
              zmiennymi.<br />
              Nasze zmienne nie modyfikują tych wartości.
            </li>
          </ul>
        </li>

        <li>Operacje porównywania</li>
        <li>Literały</li>
        <li>
          Zmienne
          <ul>
            <li>wskazują na wartoś</li>
            <li>nie są kontenerem, nie przechowują wartości tylko na nie wskazują</li>
            <li>połączenie z naszym wrzechświatem warości</li>
            <li>
              można zadeklarowa za pomocą trzech słów kluczowch:
              <ul>
                <li>
                  LET vs
                  <ul>
                    <li>zmienne, któych połączenie możemy przepina, ale definiujemy tylko raz!</li>
                    <li>let isHappy = false;</li>
                    <li>isHappy = true;</li>
                    <li>isHappy ='tak';</li>
                  </ul>
                </li>

                <li>
                  CONST vs
                  <ul>
                    <li>zmienna stała mająca połączenie z jedną wartością</li>
                    <li>const nazwa = "wartość";</li>
                    <li>
                      pobiera dane tylko raz na początku i nie można jej zmienić nawet jakbym
                      podpiął pod wartość const wartość z let
                    </li>
                    <li>let a= 20; - można zmieniać dowolnie wartość</li>
                    <li>const b = a - b przyjmuje pierwszą przypisaną wartość do a</li>
                  </ul>
                </li>
                <li>VAR - tego już raczej nie używamy</li>
              </ul>
            </li>

            <li>console.log("Nazywam się ${firstName} i mam ${age} lat.");</li>
            <li>jeśli brak apostrofów zmienna będzie wsazywać na inną zmienną o nazwie wartość</li>
            <li>w przypadku liczb nie używa się apostrofów</li>
            <li>brak typów w JS powoduje, że możemy podpiąć absolutnie wszystko pod zmienną</li>
          </ul>
        </li>
        <li>
          Obiekty {}
          <ul>
            <li>
              Prawie wszystko w JS jest obiektem (nawet typy proste, które nimi nie są zachowują się
              jak one).
            </li>
            <li>Obiekt jest <strong>strukturą</strong> danych - coś co opisuje nasze dane.</li>
            <li>{key: value,} - przecinek po każdej wartości nie licząc ostatniej</li>
            <li>klucz musi być unikalny w ramach obiektu</li>
            <li>wartość - prymitywy / funkcje / zagnieżdżenia obiektów</li>
            <li>
              W świecie obiektowym używamy innych nazw na "rzeczy", nie ma zmiennych są własności
              (property)
            </li>
            <li>Nie używamy też funkcji tylko metody (methods).</li>
            <li>
              <strong>dot notation</strong> aby wywołać własności obiektu korzystamy:
              <ul>
                <li>console.log(obiekt.value) np.</li>
                <li>console.log(deathStar.diameter) //= 120000</li>
              </ul>
            </li>
            <li>
              <strong>bracket notation</strong> - drugi sposób wywołani
              <ul>
                <li>console.log(obiekt['value'])</li>
                <li></li>
                <li></li>
              </ul>
            </li>

            <li><br /></li>
            <li>
              Immutability w obiektach - nie mutowalność w obiektach
              <ul>
                <li>Nie możemy zmieniać wartości primitive values w JS.</li>
                <li>To co zmieniamy to połączenia między nimi, a zmiennymi.</li>
                <li><br /></li>
                <li>const humanOne = {</li>
                <li>&emsp;name: 'Stefan',</li>
                <li>&emsp;age: 32</li>
                <li>}</li>
                <li><br /></li>
                <li>humanOne.age = 35;</li>
                <li><br /></li>
                <li>console.log(humanOne)</li>
                <li><br /></li>
                <li>&#8883;{name: 'Stefan", age: 35}</li>
                <li><br /></li>
                <li>const humanTwo = humanOne;</li>
                <li>
                  Każda zmiana w jednym obiekcie wpłynie na zmianę w drugim, bez znaczenia w którym.
                  Oba obiekty są równe. Jest to połączenie do obiektu a nie jego kopia.
                </li>
                <li>
                  Inaczej jest podczas kopiowania typów prostych zawsze wskazujemy na połączenia
                  wartości, nie "obserwujemy" stanu w obiekcie.
                </li>
                <li>Wskazanie na zagnieżdżony obiekt, równierz tworzy połączenie do obiektu.</li>
              </ul>
            </li>
            <li></li>
            <li></li>
          </ul>
        </li>
        <li>
          2 Funkcje
          <ul>
            <li>Na wejściu dostaje dane - argumenty</li>
            <li>Dla podanego argumentu zwraca jakąś wartość</li>
            <li>Posiada określony wzór</li>
            <li>f(x)=x*7 :</li>
            <li>
              function calculate(myNumber) {<br />
              return myNumber*7;<br />
              }
              <ul>
                <li>function - deklaracja</li>
                <li>myNumber - parametr</li>
                <li>return - słowo kluczowe</li>
                <li>myNumber*7 - Wynik</li>
              </ul>
            </li>
            <li>
              console.log(calculate(2)); - wyświetli wynik dla wskazania na wartość myNumber = 2
            </li>
            <li>calculate(2); - to samo co wyżej bez console.log</li>
            <li>Deklarujemy nazwę funkcji - ale nie musimy zawsze tego robić</li>
            <li>W środku dokonujemy obliczeń / wykonujemy zadania</li>
            <li>
              Funkcja przyjmuje argumenty (ale nie musi)
              <ul>
                <li>function hello() {</li>
                <li>console.log('hello');</li>
                <li>}</li>
                <li>hello(); - wywołanie console.log</li>
              </ul>
            </li>
            <li>
              Funkcja zwraca zawsze coś (nawet jeśli nie mamy return - wtedy zwraca undefined)
            </li>
            <li>Funkcje powstaly po to aby deklarować w nich kod, który się powtarza.</li>
            <li>(DRY - don't repeat yourself)</li>
            <li>Zwiększamy czytelność kodu.</li>
            <li>Łatwiejsze szukanie błędów.</li>
          </ul>
          <br />
          <ul>
            <li>
              => (Fat) arrow functions () => {}
              <ul>
                <li>const calculate = (myNumber) => {</li>
                <li>myNumber = myNumber +3;</li>
                <li>console.log(myNumber); //nie jest potrzebne tylko, żeby podejrzeć stan</li>
                <li>return myNumber*7;</li>
                <li>}</li>
                <li><br /></li>
                <li>calculate(2): //35</li>
                <li><br /></li>
                <li>Skrócona froma:</li>
                <li>const calculate = myNumber => myNumber+3*7</li>
                <li><br /></li>
                <li>Skraca zapis deklaracji funkcji.</li>
                <li>
                  Zwiększa czytelność (choć jest to dyskusyjne). Trzymać się w projekcie jednego
                  sposobu zapisu funkcji aby nie robić niepotrzebnego bałaganu.
                </li>
                <li>
                  Nie tworzy nowego kontekstu <em>this</em>, nie ma dostępu do <em>arguments</em> i
                  <em>super</em> - na rozmowie kwalifikacyjnej może pojawić się pytanie o to.
                </li>
                <li>
                  Nie jest zamiennikiem "tradycyjnej" funkcji (ale w większości przypadków nie widać
                  różnicy jeśli nie korzysta się <em>arguments</em> i <em>super</em>).
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </article>

    <article>
      <h2>Logika - TRUE or FALSE</h2>
      <ul>
        <li>if - jeżeli - przyjmuje po sobie porównanie</li>
        <li><br /></li>
        <li>> - lewa strona więszka od prawej</li>
        <li>&lt; - lewa strona mniejsza od prawej</li>
        <li>>= - lewa strona większa / równa od prawej</li>
        <li>&lt;= - lewa strona mniejsza / równa od prawej</li>
        <li>== - obie strony równe (= - oznacza przypisanie zmiennej)</li>
        <li>=== - obie strony równe (sprawdza najpierw typeof)</li>
        <li>
          != - nie równa się, obie strony różne
          <ul>
            <li>if('JavaScript' != 'Java') {</li>
            <li>&emsp;// wykonaj kod jeśli true</li>
            <li>}</li>
          </ul>
        </li>
        <li>!== - obie strony różne (sprawdza najpierw typeof)</li>
        <li><br /></li>
        <li>
          Falsy - fałszywe wartości, które zwracają nam false:
          <ul>
            <li>false</li>
            <li>0 - zero zawsze zwraca wartość fałszywą</li>
            <li>'',"",`` - pusty string</li>
            <li>null</li>
            <li>undefined</li>
            <li>NaN - not a number</li>
          </ul>
        </li>
        <li>
          Truthy - wszystkie inne wartości dają prawdę:
          <ul>
            <li>'Tekst'</li>
            <li>12</li>
            <li>-4</li>
            <li>{} - pusty obiekt</li>
            <li>[] - tablica</li>
            <li>true</li>
            <li>itd.</li>
          </ul>
        </li>
      </ul>
    </article>

    <article>
      <h2>&& - AND - wszystkie warunki muszą być true</h2>
      <ul>
        <li>if((myVariable == wartość) && (otherVar !== 'wartość')) {...}</li>
      </ul>
      <h2>|| - OR - przynajmniej jeden warunek musi być true</h2>

      <h2>! - NOT - odwraca wartość wyrażenia logicznego</h2>
      <ul>
        <li>if(!('JavaScript' == 'Java'))</li>
        <li>{</li>
        <li>&emsp;//ten kod się wykona</li>
        <li>}</li>
        <li><br /></li>
        <li><strong>!false => true</strong></li>
        <li><strong>!true => false</strong></li>
      </ul>
    </article>

    <article>
      <h2>else - rozbudowuje warunek</h2>
      <p></p>
      <ul>
        <li>if (myVariable == value) {</li>
        <li>&emsp;//wykonaj kod jeśli true, jeśli nie to:</li>
        <li>} else {</li>
        <li>&emsp;//wykonaj kod jeśli false</li>
        <li>}</li>
      </ul>
    </article>

    <article>
      <h2>else if - bardzo dokladnie definiujemy co należy sprawdzić</h2>
      <p></p>
      <ul>
        <li>if (myVariable == wartość1) {</li>
        <li>&emsp;//wykonaj kod jeśli true, jeśli nie to:</li>
        <li>} else if (myVariable == wartość2){</li>
        <li>&emsp;//wykonaj kod jeśli true</li>
        <li>} else {</li>
        <li>&emsp;//wykonaj kod jeśli poprzednie warunki nie są spełnione</li>
        <li>}</li>
        <li>
          pierwszy napotkany true jest wykonywany i przerywa sprawdzanie daelej, nawet jeśi kolejne
          też mogą być true
        </li>
      </ul>
    </article>

    <article>
      <h2>switch - do sprawdzania wartości</h2>
      <ul>
        <li>switch (myVariable) {</li>
        <li>&emsp;case 4: // otwarcie</li>
        <li>&emsp;&emsp;console.log('my number to 4')</li>
        <li>&emsp;break; // zamknięcie</li>
        <li>&emsp;case 8:</li>
        <li>&emsp;&emsp;console.log('my number to 8')</li>
        <li>&emsp;break;</li>
        <li>&emsp;deafault: // else w przypadku switcha</li>
        <li>&emsp;&emsp;console.log('nie wiem ile wynosisz - default response')</li>
        <li>&emsp;} // nie trzeba break bo to ostatnia domyślna odpowiedź</li>
      </ul>
    </article>

    <article>
      <h2>zapis skrócony if'a</h2>
      <ul>
        <li>(zmienna1 > zmienna2) ? console log('trude'):console.log('false')</li>
        <li>&emsp;1. porównanie, które chcę sprawdzić</li>
        <li>&emsp;2. ? - znak zapytania</li>
        <li>&emsp;3. to co ma się wykonać jeśli true</li>
        <li>&emsp;4. : - dwukropek</li>
        <li>&emsp;5. to co ma się wykonać jeśli false</li>
        <li>Nie można wrzucić do środka dłuższego kodu.</li>
        <li>Jednolinijkowe porównania na szybko, często wykorzystywane do pracy z Reactem.</li>
      </ul>
    </article>

    <article>
      <h2>Jak dostać się do wartości inputa:</h2>
      <ul>
        <li>Posługujemy się id - w konsoli wpusuję np: height, age, firstName itp</li>
        <li>otrzymuję cały input zawierający to id np.:</li>
        <li>
          &lt;input type="range" id="height" name="height" min="0" max="220" step="5" value="160"
          /&gt;
        </li>
        <li>height.value</li>
        <li>otrzymam wartość taką jaka jest obecnie</li>
        <li><br /></li>
        <li>bardziej tradycyjny sposób, przez stworzenie zmiennej:</li>
        <li>Jeśli nadpiszę: const height = "ok"</li>
        <li>otrzymam: 'ok' jako wartość zmiennej, to już nie jest ten input</li>
        <li><br /></li>
        <li>tak jakby było to wpisane gdzieś w moim JavaScriptcie aby się odnieść do inputa:</li>
        <li>const favNumber = document.querySelector('#favNumber')</li>
        <li>favNumber - otrzymam cały input</li>
        <li>favNumber.value - otrzymam wartość taką jaka jest obecnie (pobranie wartości)</li>
        <li>
          favNumber.value = 100 - wartość mogę ustalić i zmieni się na stronie, po pobraniu
          querySelectorem elementu związanego z formularzem, można modyfikować wartości formularza
          za pomocą JS
        </li>
      </ul>
    </article>

    <p>&lt;script src="main.js"&gt; &lt;/script&gt;</p>

    <footer>
      <p>
        Strona szkoleniowa z frontendu.<br />
        autor: Rafał Kubiak WTF edycja #3
      </p>
      <div>Rafał Kubiak &copy;</div>
    </footer>
  </body>
</html>
